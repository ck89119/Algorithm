#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
using namespace std;
#define dump(x) fout <<  __LINE__ << " : "<< #x << "  =  " << (x) <<endl;
#define FR(i,a,b) for(int i=(a);i<(b);++i)//[a,b)
#define CL(a,x) memset(a,x,sizeof(a))
#define MP(A,B) make_pair(A,B)
#define two(X) (1<<(X))
#define towL(X) (((int64)(1))<<(x))
#define contain(S,X) ((S&two(X))>0)
#define containL(S,X) ((S&twoL(X))>0)
//freopen("","r",stdin);
//freopen("","w",stdout);
const long long MAXN=(1LL<<62);
const int INF=(1<<30);
const double PI=acos(-1.0);
const double EPS=1e-11;
ofstream fout;
int mov[4][2][2]={
    {{2,0},{0,1}},
    {{0,2},{1,0}},
    {{0,1},{2,0}},
    {{1,0},{0,2}}
    };

class TheTilesDivTwo {
public:
    int map[4+5][50+5];
    int n,m;
    int b[4+5][50+5];
    int f[50+5][1<<4+5];
    int res;

    int dfs(int x,int y,int s,int cnt){

        if (x==n-1){
            int st=0;
            FR(i,0,n)
                st|=(b[i][y+1]<<i);
            f[y+1][st]=max(f[y+1][st],f[y][s]+cnt);

            return 0;
        }

        dfs(x+1,y,s,cnt);

        FR(k,0,4){
            int flag=1;
            FR(i,0,2)FR(j,0,2)
                if (mov[k][i][j]==2) continue;
                else if (mov[k][i][j]==1){
                    if ((x+i+y+j)%2||(b[x+i][y+j]+map[x+i][y+j]!=0)) flag=0;
                }else if (b[x+i][y+j]+map[x+i][y+j]!=0) flag=0;
            if (!flag) continue;

            FR(i,0,2)FR(j,0,2)
                if (mov[k][i][j]==2) continue;
                else b[x+i][y+j]=1;

            dfs(x+1,y,s,cnt+1);

            FR(i,0,2)FR(j,0,2)
                if (mov[k][i][j]==2) continue;
                else b[x+i][y+j]=0;

        }

        return 0;
    }

    int solve(int y,int s){
        CL(b,0);
        FR(i,0,n) b[i][y]=((s&(1<<i))>0);
        dfs(0,y,s,0);
        return 0;
    }

	int find(vector <string> board) {
	    int res;
	              // system("pause");
	    n=board.size();m=board[0].size();
	    FR(i,0,n)FR(j,0,m) map[i][j]=(board[i][j]=='X');
	    CL(f,-1);
	    f[0][0]=0;
	    FR(i,0,m-1)FR(j,0,1<<n)
            if (f[i][j]!=-1) solve(i,j);
        res=0;
        FR(i,0,1<<n) res=max(res,f[m-1][i]);
        return res;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof


bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	TheTilesDivTwo *obj;
	int answer;
	obj = new TheTilesDivTwo();
	clock_t startTime = clock();
	answer = obj->find(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	int p1;

//	{
//	 ----- test 0 -----
//	string t0[] = {"X.X","...","X.X"};
//			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//	p1 = 1;
//	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
//	 ------------------
//	}
//
//	{
//	 ----- test 1 -----
//	string t0[] = {"...","...","..."};
//			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//	p1 = 2;
//	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
//	 ------------------
//	}
//
//	{
//	 ----- test 2 -----
//	string t0[] = {"......X.X.XXX.X.XX."};
//			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//	p1 = 0;
//	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
//	 ------------------
//	}

	{
	// ----- test 3 -----
	string t0[] = {"X.....XXX.XX..XXXXXXXXX...X.XX.XX....X",
                         ".XXXX..X..XXXXXXXX....XX.X.X.X.....XXX",
                         "....XX....X.XX..X.X...XX.X..XXXXXXX..X",
                         "XX.XXXXX.X.X..X..XX.XXX..XX...XXX.X..."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 13;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
